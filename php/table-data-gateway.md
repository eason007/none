# Table Data Gateway

一直以來，最考驗web開發者功力的，都不是代碼到底寫得好不好，有沒有性能或者邏輯問題，而是對於數據庫的認識太淺。僅僅認為數據庫就是簡單存儲數據的地方，從來沒有意識到一個具備良好數據表設計的系統，才是體現開發者能力的根本。

特別到了PHP時代，mysql太快了，快到很多人以為就是select、update、delete、insert就可以了。但當他們面對的數據量達到十萬、百萬、千萬級別的時候，才發覺原來自己一點都不會**web開發**。特別到了關聯查詢，內聯（inner join）、外聯（outer join）、左聯（left join）、右聯（right join）就夠燒掉不少人的腦細胞了。

所以ORM自然而然的從java的Hibernate 傳授而來。而最常見的就是Table Data Gateway和Active Record兩種模式。

優劣之爭不想再述，看看以下引用吧：

> 活动记录（Active Record）：一个对象，它包装数据库表或视图中的某一行，封装数据库访问，并在这些数据上增加了领域逻辑。

> 举个例子来说，一个图书数据表，每一条记录就是一本图书的信息。那么采用 Active Record 时，每一本图书就是一个 Active Record 对象实例。

> 在 Ruby On Rails 中，Active Record 除了最基本的将数据记录和一个对象互相映射外，还提供了数据（而不是对象）间关联关系的处理。例如：

> * 一本图书有一个或者多个作者，所以每一个图书对象都和多个作者对象关联。反过来一个作者可以写多本书，所以一个作者对象也和多个图书对象关联。*

> RoR 中，对 Active Record 模式的实现完全利用了 Ruby 语言的灵活性，简短几行代码就可以定义一个关联。并且通过复杂的 ActiveRecord:Base 对象，提供了 CRUD（创建、读取、更新、删除）操作的默认处理。所以使用 RoR 时，绝大部分常见的数据库操作只需要很少量的代码就可以完成，大大提高了开发效率。

> 但 Active Record 模式也不是完美的，Active Record 存在不少缺点。

> Active Record 模式并不能够真正适合完全面向对象的应用程序。因为 Active Record 模式本质上就要求一个对象必须和一个数据表对应。但在完全面向对象的应用程序中，数据和操作数据的方法很可能分布在各个不同的对象中，这些对象却并没有和某一个数据表完全对应，而且 Active Record 无法很好的处理对象的继承、聚合等面向对象常见的对象间关系；

> 如果在 Active Record 模式中添加了对数据关系（注意，不是对象关系）的处理，那么还要注意性能问题：

> 假如一个 Active Record 对象有多个关联。那么我取出一个对象时，很可能就连带取出了其他不少对象。但这些对象可能根本就是本次操作用不上的。其次，将对象更新到数据库时，也需要对关联的对象进行处理，否则对关联对象的修改就会丢失。

> 虽然可以用各种技巧来避免这些情况，但毫无疑问需要开发者对 RoR 的 Active Record 很熟悉才行。否则看上去很简单的代码，背后则会是噩梦般的数据库操作。

> 其次，假设我们要将数据库中每本书的单价减半，那么采用 Active Record 模式时，就必须首先读取所有的记录并实例化为对象，然后更新对象属性，再写回数据库。可想而知这样会有多差的效率。

> 当然了，实际开发中没有人会这样做。开发者会编写一个单独的方法，用一条 SQL 语句完成对批量数据的更新。但也说明 Active Record 模式不适合批量处理数据，而现实世界中，批量处理数据的需求随处可见。